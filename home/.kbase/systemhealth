#!/bin/bash
# Script written by Warith Al Maawali
# (c) 2018 Founder of Eagle Eye Digital Solutions
# http://www.digi77.com
# http://www.om77.net
# script starts here:

# Testing and examples
#sudo -H -u kodachi bash -c 'echo $HOME' > $Myhome_path/Desktop/t.txt

#Cheatsheet:

 #-eq # equal
#-ne # not equal
#-lt # less than
#-le # less than or equal
#-gt # greater than
#-ge # greater than or equal


#A; B    # Run A and then B, regardless of success of A
#A && B  # Run B if and only if A succeeded
#A || B  # Run B if and only if A failed
#A &     # Run A in background.


cd $(dirname $0) 
source Globalconfig;



# Set global;
e="";
IP_ADDR="";
TIP_ADDR="";
IP_ADDRPublic="";
originalIP="";
theCountry="";
theCountryx="";
kodachi_version=$Kodachi_version;
netIP='google.com';
randomdomain="";
vpntype="kodachivpn";
sameipCounter=0;
killVPNTorcounterpopup=0;
tornullipcounter=0;
# Hay don't cheat leave this value alone :p
securityScore=0;
 


# If no su privileges available, try to get them
if [[ ! "$(whoami)" == "root" ]] ; then
	
	# No sudo available? Then we can't get su privs. Advise and exit
	if [[ $(which sudo) == "" ]] ; then
		echo "'sudo' package missing! Please install."
		echo "e.g.: apt-get install sudo" 
		exit 1
	fi

	echo "Requesting su permissions..."
	# Run this script with sudo privs
	sudo $0 $*
		# If running this script with su privs failed, advise to do so manually and exit
		if [[ $? > 0 ]] ; then
		echo
		echo "Acquiring su permission failed!"
		echo "Please run this script with sudo permissions!"
		echo "(e.g. 'sudo $0' or 'sudo bash $0')"
		echo
		exit 1
	fi
exit 0
fi


 
 

# detect empty arguments
if [ $# -eq 0 ]; then
	echo "No arguments entered"
	
	#pause 'Press [Enter] key to exit...or Ctrl c to quit the script and run it again correctly'	
        #exit 1
fi


# Accept command line arguments
while [ $# -gt 0 ]
do
    case "$1" in
    -a)  myAction=$2 ; shift;;       
	--)	shift; break;;
	-*)
	    echo >&2 \
	    "usage: $0 [-v] [-f file] [file ...]"
	    exit 1;;
	*)  break;;	# terminate while loop
    esac
    shift
done



 
#Set of functions
function getID()
{
       
    a=$(sudo dmidecode -s system-uuid);
	b=$(sudo dmidecode -s system-serial-number);
	c=$(sudo dmidecode |grep -w ID:|head -n1);
	m=$a.$b.$c;
	e=$(md5sum <<<$m| tr -d -|tr -d ' ');
    echo $e | cut -d ' ' -f 1 > $Mykodachi_path/HWID;
       
}

function getMem()
{
	echo " Inside memory function";
	hw_mem=0
	free_mem=0
	human=1024
	mem_info=$(</proc/meminfo)
	mem_info=$(echo $(echo $(mem_info=${mem_info// /}; echo ${mem_info//kB/})))
		
	for m in $mem_info; do
		if [[ ${m//:*} = MemTotal ]]; then
			memtotal=${m//*:}
		fi

		if [[ ${m//:*} = MemFree ]]; then
			memfree=${m//*:}
		fi

		if [[ ${m//:*} = Buffers ]]; then
			membuffer=${m//*:}
		fi

		if [[ ${m//:*} = Cached ]]; then
			memcached=${m//*:}
		fi			
	done

	usedmem="$(((($memtotal - $memfree) - $membuffer - $memcached) / $human))"
	totalmem="$(($memtotal / $human))"
	mem="${usedmem}M / ${totalmem}M"
	echo $mem > $Mykodachi_path/Memused;
	echo "Mem details: "$mem;
	
	
}	


function getBan()
{
    getID
    #Banned Stuff
    Ban_Status=$(sudo curl -G -s -m 30 "https://www.digi77.com/software/vpn/ko_band_check.php" --data-urlencode "ko_hwid=$e" --data-urlencode "ko_ver=$kodachi_version")
    echo $Ban_Status | cut -d ' ' -f 1 > $Mykodachi_path/BandSatus;
    echo "getBan: Kodachi status:" $Ban_Status;
}

function banAction()
{
    
    SERVICE='openvpn';
	if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
	then
		sudo killall -SIGINT openvpn;
	fi
    sudo killall tor; 
    TIP_ADDR=""; 
    cat $Mykodachi_path/dns/dns4 > $Mykodachi_path/dns/dns1;
	sudo bash -c 'cat dns/dns4 > /etc/resolv.conf'; 
	echo "0" > $Mykodachi_path/dns/autodnscrypt;
	echo "0" > $Mykodachi_path/torenabled;
	echo "Disabled" > $Mykodachi_path/vpntype;
	sudo service dnscrypt-proxy stop  
	
	
    #only if run by system cron  
    #export DISPLAY=:0.0 && export XAUTHORITY=$Myhome_path/.Xauthority && sudo -u kodachi /usr/bin/notify-send Sorry! "You have been banned from our network please contact support@digi77.com"
    #export DISPLAY=:0.0 && export XAUTHORITY=$Myhome_path/.Xauthority && sudo -u kodachi /usr/bin/conky -c $Mykodachi_path/.conkyrc4;
    
    notify-send -i $notifyIcon  "You have been banned from $OS_name VPN network please contact support@digi77.com"
	
    
}


function getVersion()
{
   KO_Version=$(sudo curl -s -m 30 https://www.digi77.com/software/kodachi/version|cut -d , -f 2)
	echo "getVersion: Kodachi Net Version is: @$KO_Version@  System version: @$kodachi_version@";
	echo -n $KO_Version > $Mykodachi_path/version;

	if [ -n "$KO_Version" ]  
		then
		if [[ "$KO_Version" != *$kodachi_version* ]]
		then
			    
			#only if run by system cron
			#export DISPLAY=:0.0 && export XAUTHORITY=$Myhome_path/.Xauthority && sudo -u kodachi /usr/bin/conky -c $Mykodachi_path/.conkyrc5;
			echo "!" > $Mykodachi_path/newversionalert;	
			echo "version no match";		
				
		else
			rm -f $Mykodachi_path/newversionalert;	
			echo "version match";
			
		fi	
	fi 
	
}

function checkDNSisRunning()
{
	dnsstatus=$(cat $Mykodachi_path/dns/autodnscrypt);
	SERVICE='dnscrypt-proxy';
	if [[ "$dnsstatus" == 1 ]]
	then
		echo "autodnscrypt status is : $dnsstatus";
		if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)
		then
			echo "No DNS Crypt process Starting Dnscrypt";
			sudo service dnscrypt-proxy stop    
			sudo service dnscrypt-proxy start			
			sudo bash -c 'cat dns/dns0 > /etc/resolv.conf';			
		else
			echo "Dnscrypt running no issue";
		fi
	fi
}


function resetips()
{
		IP_ADDRPublic="";
		TIP_ADDR="";
		echo "" > $Mykodachi_path/.eeds-ipinfo;
		echo "" > $Mykodachi_path/.eeds-tipinfo;
	
}

function startvpnfunction()
{
   
    vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' ');
    # make sure we have internet before starting    
    ping -c1 -W 2 "$netIP" &> /dev/null
	if [ $? -eq 0 ]; 
	then
		
		if [[ "$vpntype" == *kodachivpn* ]]
		then
			notify-send -i $notifyIcon "Kodachi VPN will start now"
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				echo "#### Will kill vpn now before starting it ####";
				sudo killall -SIGINT openvpn;			    
			
			fi	
					 
		
			getID;
			sudo echo -n "kodachi|" > /etc/openvpn/auth
			sudo echo $e | cut -d ' ' -f 1 >> /etc/openvpn/auth;	
			sudo echo "cf90b117a31e7c2bb53cac3186b867b0" >> /etc/openvpn/auth;	
			if(sudo timeout 60 wget "https://digi77.com/software/kodachi/kodachi-vpn.zip" -q)
			then
				unzip -P a30@06e61-79-34-88-A4-C3@ kodachi-vpn.zip -d /etc/openvpn/
				rm -f kodachi-vpn.zip
				 
			
				#Get proto  port ip
				theOvfile="/etc/openvpn/kodachi-vpn.ovpn";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1);
				theCountry=$(geoiplookup $IP_ADDRPublic|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//');	
				if [[ "$theCountry" == *"not found"* ]]
				then
					echo "Going to get country online iplocate.io for normal ip:$theCountry";
					theCountry=$(curl https://www.iplocate.io/api/lookup/$IP_ADDRPublic -s -m 20 |jq -r '.country');
					
					if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
					then
						echo "Going to get country online ip2c.org for normal ip:$theCountry";
						theCountry=$(curl http://ip2c.org/$IP_ADDRPublic -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
						if [[ ! -n $theCountry ]]
						then
							theCountry="Not found";
						fi
					fi 							
							
				fi				
				
				ping -c1 -W 2 "$theVPNipUsed" &> /dev/null
				if [ $? -eq 0 ]; 
				then
					sudo openvpn --daemon --config /etc/openvpn/kodachi-vpn.ovpn > /dev/null 2>&1
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "Kodachi VPN will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")" 
				
					NEWLINE=$'\n'
					theVPNport="port=$theVPNport";
					theVPNproto="protocolu=$theVPNproto";
					theVPNipUsed="theIPu=$theVPNipUsed";
					theVPNProfile="theProfile=kodachi-vpn.ovpn";
					echo "$theVPNport$NEWLINE$theVPNproto$NEWLINE$theVPNProfile" >  $Mykodachi_path/vpnattributes;
					echo "$OS_name VPN Process Done";
					resetips;
				
				else
					theTime=$(date +%H:%M);
					notify-send -i $notifyIcon "$OS_name VPN skipping offline node:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")" 
					
				fi
				sudo rm -f /etc/openvpn/kodachi-vpn.ovpn;
				sudo rm -f /etc/openvpn/auth;					
			else
				notify-send -i $notifyIcon "Failed to download $OS_name VPN";
			fi
		fi # end kodachi vpn
		
		
		
		
		
		if [[ "$vpntype" == *vpngate* ]]
		then
			# get variables from config
			source $VPN_configs_path/vpngatesetup
			if [[ $randomnvpngate==0 ]] || [[ $randomnvpngate==1 ]]   
			then
		
				notify-send -i $notifyIcon "VPNGate will start now"
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;			    
				
				fi	
							 
			
				if [[ "$randomnvpngate" == 1 ]]
				then
				
					randomvpngatepick=$(ls $VPN_gate_ovpn_dir |sort -R|shuf -n 1);
					echo "Pickced up random profile for VPNGate:$randomvpngatepick";
				else
					randomvpngatepick=$vpngateprofilenametouse;
					echo "User has selected profile for VPNGate:$randomvpngatepick";
					if [[ ! -f "$VPN_gate_ovpn_dir/$randomvpngatepick" ]] || [[ ! -n "$randomvpngatepick" ]];  
					then
						notify-send -i $notifyIcon "VPNGate profile $randomvpngatepick is missing correct the vpngatesetup file:" \ "$VPN_configs_path/vpngatesetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_gate_ovpn_dir/$randomvpngatepick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1);
				if [[ "$theCountry" == *"not found"* ]]
				then
					echo "Going to get country online iplocate.io for normal ip:$theCountry";
					theCountry=$(curl https://www.iplocate.io/api/lookup/$IP_ADDRPublic -s -m 20 |jq -r '.country');
					
					if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
					then
						echo "Going to get country online ip2c.org for normal ip:$theCountry";
						theCountry=$(curl http://ip2c.org/$IP_ADDRPublic -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
						if [[ ! -n $theCountry ]]
						then
							theCountry="Not found";
						fi
					fi 							
							
				fi				
				
				ping -c1 -W 2 "$theVPNipUsed" &> /dev/null
				if [ $? -eq 0 ]; 
				then
					sudo openvpn --daemon --config $VPN_gate_ovpn_dir/$randomvpngatepick > /dev/null 2>&1;
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "VPNGate will connect to:" "$(echo -e "Profile: $randomvpngatepick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")" 
				
					NEWLINE=$'\n'
					theVPNport="port=$theVPNport";
					theVPNproto="protocolu=$theVPNproto";
					theVPNipUsed="theIPu=$theVPNipUsed";
					theVPNProfile="theProfile=$randomvpngatepick";
					echo "$theVPNport$NEWLINE$theVPNproto$NEWLINE$theVPNProfile" >  $Mykodachi_path/vpnattributes;
					echo "VPNGATE VPN Process Done";
					resetips;
				
				else
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "VPNGate skipping offline node:" "$(echo -e "Profile: $randomvpngatepick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")" 
					
				fi
			else
				notify-send -i $notifyIcon "VPNGate needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				gedit $VPN_configs_path/vpngatesetup;			   	
			
			fi
			 
		fi	# end vpngate
		
		
		
		
		
		if [[ "$vpntype" == *kernvpn* ]]
		then
			# get variables from config
			source $VPN_configs_path/kernvpnsetup
			if [[ $randomkernvpn==0 ]] || [[ $randomkernvpn==1 ]]   
			then
		
				notify-send -i $notifyIcon "KernVPN will start now"
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;			    
				
				fi	
							 
			
				if [[ "$randomkernvpn" == 1 ]]
				then
				
					randomkernvpnpick=$(ls $VPN_kern_ovpn_dir |sort -R|shuf -n 1);
					echo "Pickced up random profile for KernVPN:$randomkernvpnpick";
				else
					randomkernvpnpick=$kernvpnfilenameuse;
					echo "User has selected profile for KernVPN:$randomkernvpnpick";
					if [[ ! -f "$VPN_kern_ovpn_dir/$randomkernvpnpick" ]] || [[ ! -n "$randomkernvpnpick" ]];  
					then
						notify-send -i $notifyIcon "KernVPN profile $randomkernvpnpick is missing correct the kernvpnsetup file:" \ "$VPN_configs_path/kernvpnsetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_kern_ovpn_dir/$randomkernvpnpick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1); 
				if [[ "$theCountry" == *"not found"* ]]
				then
					echo "Going to get country online iplocate.io for normal ip:$theCountry";
					theCountry=$(curl https://www.iplocate.io/api/lookup/$IP_ADDRPublic -s -m 20 |jq -r '.country');
					
					if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
					then
						echo "Going to get country online ip2c.org for normal ip:$theCountry";
						theCountry=$(curl http://ip2c.org/$IP_ADDRPublic -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
						if [[ ! -n $theCountry ]]
						then
							theCountry="Not found";
						fi
					fi 							
							
				fi				
				
				ping -c1 -W 2 "$theVPNipUsed" &> /dev/null
				if [ $? -eq 0 ]; 
				then
					sudo openvpn --daemon --config $VPN_kern_ovpn_dir/$randomkernvpnpick > /dev/null 2>&1;
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "KernVPN will connect to:" "$(echo -e "Profile: $randomkernvpnpick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")" 
				
					NEWLINE=$'\n'
					theVPNport="port=$theVPNport";
					theVPNproto="protocolu=$theVPNproto";
					theVPNipUsed="theIPu=$theVPNipUsed";
					theVPNProfile="theProfile=$randomkernvpnpick";
					echo "$theVPNport$NEWLINE$theVPNproto$NEWLINE$theVPNProfile" >  $Mykodachi_path/vpnattributes;
					echo "Kern VPN Process Done";
					resetips;
				
				else
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "KernVPN skipping offline node:" "$(echo -e "Profile: $randomkernvpnpick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")" 
					
				fi
			else
				notify-send -i $notifyIcon "KernVPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				gedit $VPN_configs_path/kernvpnsetup;			   	
			
			fi
			 
		fi	# end Kernvpn	
		
		
			 
		
		 
	
		if [[ "$vpntype" == *nordvpn* ]]
		then
			# get variables from config
			source $VPN_configs_path/nordvpnsetup
			
			if [[ -n "$NordVPNusername" ]] ||  [[  -n "$NordVPNpassword" ]]
			then
			 
				notify-send -i $notifyIcon "NordVPN will start now"
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;			    
				
				fi	
						 
			
				if [[ "$randomnordvpn" == 1 ]]
				then
				
					randomNordpick=$(ls $VPN_nord_ovpn_dir |sort -R|shuf -n 1);
					echo "Pickced up random profile for NordVPN:$randomNordpick";
				else
					randomNordpick=$nordprofilenametouse;
					echo "User has selected profile for NordVPN:$randomNordpick";
					if [[ ! -f "$VPN_nord_ovpn_dir/$randomNordpick" ]] || [[ ! -n "$randomNordpick" ]];  
					then
						notify-send -i $notifyIcon "NordVPN profile $randomNordpick is missing correct the nordvpnsetup file:" \ "$VPN_configs_path/nordvpnsetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_nord_ovpn_dir/$randomNordpick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1);
				if [[ "$theCountry" == *"not found"* ]]
				then
					echo "Going to get country online iplocate.io for normal ip:$theCountry";
					theCountry=$(curl https://www.iplocate.io/api/lookup/$IP_ADDRPublic -s -m 20 |jq -r '.country');
					
					if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
					then
						echo "Going to get country online ip2c.org for normal ip:$theCountry";
						theCountry=$(curl http://ip2c.org/$IP_ADDRPublic -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
						if [[ ! -n $theCountry ]]
						then
							theCountry="Not found";
						fi
					fi 							
							
				fi				
				
				ping -c1 -W 2 "$theVPNipUsed" &> /dev/null
				if [ $? -eq 0 ]; 
				then
					NEWLINE=$'\n'
					echo "$NordVPNusername$NEWLINE$NordVPNpassword" > $VPN_configs_path/nordvpnauth.txt
					sudo openvpn --daemon --config $VPN_nord_ovpn_dir/$randomNordpick > /dev/null 2>&1;
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "NordVPN will connect to:" "$(echo -e "Profile: $randomNordpick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")" 
				
					NEWLINE=$'\n'
					theVPNport="port=$theVPNport";
					theVPNproto="protocolu=$theVPNproto";
					theVPNipUsed="theIPu=$theVPNipUsed";
					theVPNProfile="theProfile=$randomNordpick";
					echo "$theVPNport$NEWLINE$theVPNproto$NEWLINE$theVPNProfile" >  $Mykodachi_path/vpnattributes;
					echo "NORDVPN Process Done";
				    rm -f $VPN_configs_path/nordvpnauth.txt;
				    resetips;
				else
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "NordVPN skipping offline node:" "$(echo -e "Profile: $randomNordpick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")" 
					 	
				fi
			else
				notify-send -i $notifyIcon "NordVPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				gedit $VPN_configs_path/nordvpnsetup;			   	
			
			fi
			 
		fi	# end nordvpn	 	
		
		
		
		
		if [[ "$vpntype" == *hideme* ]]
		then
			# get variables from config
			source $VPN_configs_path/hidemevpnsetup
			
			if [[ -n "$HidemeVPNusername" ]] ||  [[  -n "$HidemeVPNpassword" ]]
			then
			 
				notify-send -i $notifyIcon "HidemeVPN will start now"
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;			    
				
				fi	
						 
			
				if [[ "$randomhidemevpn" == 1 ]]
				then
				
					randomhidemepick=$(ls $VPN_hideme_ovpn_dir |sort -R|shuf -n 1);
					echo "Pickced up random profile for HidemeVPN:$randomhidemepick";
				else
					randomhidemepick=$hidemeprofilenametouse;
					echo "User has selected profile for HidemeVPN:$randomhidemepick";
					if [[ ! -f "$VPN_hideme_ovpn_dir/$randomhidemepick" ]] || [[ ! -n "$randomhidemepick" ]];  
					then
						notify-send -i $notifyIcon "HidemeVPN profile $randomhidemepick is missing correct the hidemevpnsetup file:" \ "$VPN_configs_path/hidemevpnsetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_hideme_ovpn_dir/$randomhidemepick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1);
				if [[ "$theCountry" == *"not found"* ]]
				then
					echo "Going to get country online iplocate.io for normal ip:$theCountry";
					theCountry=$(curl https://www.iplocate.io/api/lookup/$IP_ADDRPublic -s -m 20 |jq -r '.country');
					
					if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
					then
						echo "Going to get country online ip2c.org for normal ip:$theCountry";
						theCountry=$(curl http://ip2c.org/$IP_ADDRPublic -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
						if [[ ! -n $theCountry ]]
						then
							theCountry="Not found";
						fi
					fi 							
							
				fi				
				
				ping -c1 -W 2 "$theVPNipUsed" &> /dev/null
				if [ $? -eq 0 ]; 
				then
					NEWLINE=$'\n';
					echo "$HidemeVPNusername$NEWLINE$HidemeVPNpassword" > $VPN_configs_path/hidemevpnauth.txt
					sudo openvpn --daemon --config $VPN_hideme_ovpn_dir/$randomhidemepick > /dev/null 2>&1;
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "HidemeVPN will connect to:" "$(echo -e "Profile: $randomhidemepick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")" 
				
					NEWLINE=$'\n'
					theVPNport="port=$theVPNport";
					theVPNproto="protocolu=$theVPNproto";
					theVPNipUsed="theIPu=$theVPNipUsed";
					theVPNProfile="theProfile=$randomhidemepick";
					echo "$theVPNport$NEWLINE$theVPNproto$NEWLINE$theVPNProfile" >  $Mykodachi_path/vpnattributes;
					echo "HideMe Process Done"
				    rm -f $VPN_configs_path/hidemevpnauth.txt;
				    resetips;
				else
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "HidemeVPN skipping offline node:" "$(echo -e "Profile: $randomhidemepick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")" 
					 	
				fi
			else
				notify-send -i $notifyIcon "HidemeVPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				gedit $VPN_configs_path/hidemevpnsetup;			   	
			
			fi
			 
		fi	# end hidemevpn	 	
		
		
		
		if [[ "$vpntype" == *proton* ]]
		then
			# get variables from config
			source $VPN_configs_path/protonvpnsetup
			
			if [[ -n "$ProtonVPNusername" ]] ||  [[  -n "$ProtonVPNpassword" ]]
			then
			 
				notify-send -i $notifyIcon "ProtonVPN will start now"
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;			    
				
				fi	
						 
			
				if [[ "$randomprotonvpn" == 1 ]]
				then
				
					if [[ "$protonfree" == 1 ]]
					then
						randomprotonpick=$(ls $VPN_proton_ovpn_dir |grep free |sort -R|shuf -n 1);
						echo "Pickced up random free profile for ProtonVPN:$randomprotonpick";
					else
						randomprotonpick=$(ls $VPN_proton_ovpn_dir |grep -v free |sort -R|shuf -n 1);
						echo "Pickced up random profile for ProtonVPN:$randomprotonpick";
					fi
				else
					randomprotonpick=$protonprofilenametouse;
					echo "User has selected profile for ProtonVPN:$randomprotonpick";
					if [[ ! -f "$VPN_proton_ovpn_dir/$randomprotonpick" ]] || [[ ! -n "$randomprotonpick" ]];  
					then
						notify-send -i $notifyIcon "ProtonVPN profile $randomprotonpick is missing correct the protonvpnsetup file:" \ "$VPN_configs_path/protonvpnsetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_proton_ovpn_dir/$randomprotonpick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|head -n 1|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1);
				if [[ "$theCountry" == *"not found"* ]]
				then
					echo "Going to get country online iplocate.io for normal ip:$theCountry";
					theCountry=$(curl https://www.iplocate.io/api/lookup/$IP_ADDRPublic -s -m 20 |jq -r '.country');
					
					if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
					then
						echo "Going to get country online ip2c.org for normal ip:$theCountry";
						theCountry=$(curl http://ip2c.org/$IP_ADDRPublic -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
						if [[ ! -n $theCountry ]]
						then
							theCountry="Not found";
						fi
					fi 							
							
				fi				
				
				ping -c1 -W 2 "$theVPNipUsed" &> /dev/null
				if [ $? -eq 0 ]; 
				then
					NEWLINE=$'\n';
					echo "$ProtonVPNusername$NEWLINE$ProtonVPNpassword" > $VPN_configs_path/protonvpnauth.txt
					sudo openvpn --daemon --config $VPN_proton_ovpn_dir/$randomprotonpick > /dev/null 2>&1;
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "ProtonVPN will connect to:" "$(echo -e "Profile: $randomprotonpick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")" 
				
					NEWLINE=$'\n'
					theVPNport="port=$theVPNport";
					theVPNproto="protocolu=$theVPNproto";
					theVPNipUsed="theIPu=$theVPNipUsed";
					theVPNProfile="theProfile=$randomprotonpick";
					echo "$theVPNport$NEWLINE$theVPNproto$NEWLINE$theVPNProfile" >  $Mykodachi_path/vpnattributes;
					echo "Proton Process Done"
				    rm -f $VPN_configs_path/protonvpnauth.txt;
				    resetips;
				else
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "ProtonVPN skipping offline node:" "$(echo -e "Profile: $randomprotonpick\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")" 
					 	
				fi
			else
				notify-send -i $notifyIcon "ProtonVPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				gedit $VPN_configs_path/protonvpnsetup;			   	
			
			fi
			 
		fi	# end protonvpn	 	
		
		
		
		
		if [[ "$vpntype" == *ownvpn* ]]
		then
			source $VPN_configs_path/myownvpnsetup			
			if grep "dev tun" $VPN_configs_path/myownvpn.ovpn > /dev/null		 
			then
		
				notify-send -i $notifyIcon "OwnVPN will start now"
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;			    
				
				fi	
						 
			
 
			
				#Get proto  port ip
				theOvfile="$VPN_configs_path/myownvpn.ovpn";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				theCountry=$(geoiplookup $theVPNipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1); 
				if [[ "$theCountry" == *"not found"* ]]
				then
					echo "Going to get country online iplocate.io for normal ip:$theCountry";
					theCountry=$(curl https://www.iplocate.io/api/lookup/$IP_ADDRPublic -s -m 20 |jq -r '.country');
					
					if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
					then
						echo "Going to get country online ip2c.org for normal ip:$theCountry";
						theCountry=$(curl http://ip2c.org/$IP_ADDRPublic -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
						if [[ ! -n $theCountry ]]
						then
							theCountry="Not found";
						fi
					fi 							
							
				fi					
				
				ping -c1 -W 2 "$theVPNipUsed" &> /dev/null
				if [ $? -eq 0 ]; 
				then
					if [[ "$need_user_password" == 1 ]]
					then
						NEWLINE=$'\n';
						echo "$ownvpnusrname$NEWLINE$ownvpnpassword" > $VPN_configs_path/myownvpnauth.txt ;
					fi
					sudo openvpn --daemon --config $VPN_configs_path/myownvpn.ovpn > /dev/null 2>&1;
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "OwnVPN will connect to:" "$(echo -e "Profile: myownvpn.ovpn\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")" 
				
					NEWLINE=$'\n'
					theVPNport="port=$theVPNport";
					theVPNproto="protocolu=$theVPNproto";
					theVPNipUsed="theIPu=$theVPNipUsed";
					theVPNProfile="theProfile=myownvpn.ovpn";
					echo "$theVPNport$NEWLINE$theVPNproto$NEWLINE$theVPNProfile" >  $Mykodachi_path/vpnattributes;
					echo "OwnVPN Process Done"
				    rm -f $VPN_configs_path/myownvpnauth.txt;
				    resetips;
				else
					theTime=$(date +%H:%M);
					notify-send -t 30000 -i $notifyIcon "OwnVPN skipping offline node:" "$(echo -e "Profile: myownvpn.ovpn\nIP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nTime: $theTime")" 
					
				fi
			else
				notify-send -i $notifyIcon "OwnVPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				gedit $VPN_configs_path/myownvpn.ovpn;	
				gedit $VPN_configs_path/myownvpnsetup;			   	
			
			fi
			 
		fi	# end Ownvpn
			  
		 
	
		# Auto start and stop tor
		autotorvpn=$(cat $Mykodachi_path/torenabled|tr -d ' '); 
		autotornovpn=$(cat $Mykodachi_path/torenablednovpn|tr -d ' '); 
		if [[ "$autotorvpn" == *1* ]] || [[ "$autotornovpn" == *1* ]] # || [[ "$torifySystem" == *Yes* ]] # don't do it !
		then
			
			
			echo "tor is set to autotorvpn:$autotorvpn";
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				
				sleep 30;
				echo "Sleeping for 30 second";
				echo "restart tor after vpn restart";
				sudo /etc/init.d/tor restart;
				TIP_ADDR="";
				tornullipcounter=0;
						
			
			fi
				
		fi
		
		
	
	
	
	else
		echo "No Net we can't start vpns";
	fi
}







function fetchNormalIP()
{ 
	theCountry="";
	if [ ! -n $randomdomain ]
	then
		echo " Random domain was empty so we set digi77 domain";
		randomdomain="https://www.digi77.com/software/vpn/ipcheckplain.php";
	fi
	
	# Format sample 95.174.64.202:[secure]:Germany
	IP_ADDRPublic=$(sudo curl -s -m 30 $randomdomain )	
	# Remove empty space
	IP_ADDRPublic=$(echo $IP_ADDRPublic|sed 's/ //g'|xargs);
	IP_ADDRPublic=$(echo $IP_ADDRPublic|grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}');
	
	if [ -n $IP_ADDRPublic ]     
	then 
		theCountry=$(geoiplookup $IP_ADDRPublic|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//');	
		if [[ "$theCountry" == *"not found"* ]]
		then
		    echo "Going to get country online iplocate.io for normal ip:$theCountry";
			theCountry=$(curl https://www.iplocate.io/api/lookup/$IP_ADDRPublic -s -m 20 |jq -r '.country');
			
			if [[ "$theCountry" == *"null"* ]] || [[ ! -n $theCountry ]]
			then
				echo "Going to get country online ip2c.org for normal ip:$theCountry";
				theCountry=$(curl http://ip2c.org/$IP_ADDRPublic -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
				if [[ ! -n $theCountry ]]
				then
					theCountry="Not found";
				fi
			fi 							
					
		fi				
	fi 	 

	#echo " Entering fetchNormalIP function";
	SERVICE='openvpn';
    if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
    then
        if [[ "$vpntype" == *ownvpn* ]] ||  [[ "$vpntype" == *kodachivpn* ]]  ||  [[ "$vpntype" == *nordvpn* ]]  || [[ "$vpntype" == *vpngate* ]] || [[ "$vpntype" == *kernvpn* ]] || [[ "$vpntype" == *hideme* ]] || [[ "$vpntype" == *proton* ]]
		then
			#IP_ADDRPublic=$(echo $IP_ADDRPublic|sed 's/ //g'|xargs);
			originalIP=$(echo $originalIP | xargs);			 
			if [ -n "$IP_ADDRPublic" ] 
			then
				if [ "$IP_ADDRPublic" != "$originalIP" ] ; then 					
					echo $IP_ADDRPublic":[secure]:"$theCountry > $Mykodachi_path/.eeds-ipinfo;
					echo "The Normal ip:"$IP_ADDRPublic":[secure]"$theCountry;
					echo "$originalIP != $IP_ADDRPublic";				
				else				
					torifySystem=$(cat $Mykodachi_path/torifysystemstatus);
					if [[ "$torifySystem" == *No* ]]
					then
						echo $IP_ADDRPublic":[notsecure]:"$theCountry> $Mykodachi_path/.eeds-ipinfo;
						echo "The Normal ip:"$IP_ADDRPublic":[notsecure]"$theCountry;
						echo "No1:$originalIP == $IP_ADDRPublic";
					else
						echo $IP_ADDRPublic":[secure]:"$theCountry > $Mykodachi_path/.eeds-ipinfo;
						echo "The Normal ip:"$IP_ADDRPublic":[secure]"$theCountry;
						echo "$originalIP != $IP_ADDRPublic";			
					
					fi
				fi
			fi
        fi
    else
        if [ -n "$IP_ADDRPublic" ] 
		then
			echo $IP_ADDRPublic":[notsecure]:"$theCountry> $Mykodachi_path/.eeds-ipinfo;
			echo "The Normal ip:"$IP_ADDRPublic":[notsecure]"$theCountry;
			originalIP=$IP_ADDRPublic;
			echo "No2:$originalIP == $IP_ADDRPublic";
			echo $originalIP > $Mykodachi_path/.eeds-oipinfo;
			echo $theCountry > $Mykodachi_path/.eeds-ocipinfo;
		fi
    fi 
    
    #Refrence update ip DB
    #cd /usr/share/geoip
	#wget http://geolite.maxmind.com/download/geoip/database/GeoLiteCountry/GeoIP.dat.gz || { echo 'Could not download GeoLiteCountry, exiting.' ; exit 1; }
	#wget http://geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gz || { echo 'Could not download GeoLiteCity, exiting.' ; exit 1; }
	#gunzip -f GeoIP.dat.gz
	#gunzip -f GeoLiteCity.dat.gz
	#echo "y"|mv GeoLiteCity.dat GeoIPCity.dat
	
}

function fetchKodachiIP ()
{ 
	SERVICE='openvpn';
    if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
    then
		getID
		IP_ADDR=$(sudo curl -G -s -m 30 "https://www.digi77.com/software/vpn/ipcheckplain.php"  --data-urlencode "ko_hwid=$e" --data-urlencode "ko_ver=$kodachi_version")	
		# Remove empty space
		IP_ADDR=$(echo $IP_ADDR | xargs);
		IP_ADDR=$(echo $IP_ADDR| grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}');
		echo "fetchKodachiIP: The Kodachi ip:" $IP_ADDR;
		#echo $IP_ADDR > $Mykodachi_path/.eeds-ipinfo;
	else
		fetchNormalIP;
	
	fi
}



function fetchTorIP()
{

	
	
	SERVICE='tor-service';
	if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)
	then		
		echo "Tor is not running";
	else
		
		
		if [ ! -n $randomdomain ]
		then
			echo " Random domain was empty so we set digi77 domain";
			randomdomain="https://www.digi77.com/software/vpn/ipcheckplain.php";
		fi
	
		torifySystem=$(cat $Mykodachi_path/torifysystemstatus);
		if [[ "$torifySystem" == *No* ]]
		then
			theCountryx="";
			TIP_ADDR=$(sudo curl --proxy socks5h://localhost:9050 -s -m 20 $randomdomain )
		else
		   theCountryx="";
		    TIP_ADDR=$(sudo curl -s -m 30 $randomdomain);
		fi
		# Remove empty space
		TIP_ADDR=$(echo $TIP_ADDR | xargs);	
		TIP_ADDR=$(echo $TIP_ADDR| grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}');
		#notify-send "Tor ip: $TIP_ADDR";
		if [ -n $TIP_ADDR ] || [ $TIP_ADDR == ":" ]    
		then 
			theCountryx=$(geoiplookup $TIP_ADDR|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//');	
			if [[ "$theCountryx" == *"not found"* ]]
			then
				echo "Going to get country online iplocate.io for normal ip:$theCountryx";
				theCountryx=$(curl https://www.iplocate.io/api/lookup/$TIP_ADDR -s -m 20 |jq -r '.country');
				
				if [[ "$theCountryx" == *"null"* ]] || [[ ! -n $theCountryx ]]
				then
					echo "Going to get country online ip2c.org for normal ip:$theCountryx";
					theCountryx=$(curl http://ip2c.org/$TIP_ADDR -s -m 20|cut -d ';' -f 4|sed 's/ //g'|xargs);
					if [[ ! -n $theCountryx ]]
					then
						theCountryx="Not found";
					fi
				fi 							
						
			fi				
		else
			echo "Fetch Tor function:Tor working but no ip restarting tor circuites";
		    (echo authenticate '"Auo2@s3ks@Wdq"';echo SETCONF ExitNodes={ac},{af},{ax},{al},{dz},{ad},{ao},{ai},{aq},{ag},{ar},{am},{aw},{au},{at},{az},{bs},{bh},{bd},{bb},{by},{be},{bz},{bj},{bm},{bt},{bo},{ba},{bw},{bv},{br},{io},{vg},{bn},{bg},{bf},{bi},{kh},{cm},{ca},{cv},{ky},{cf},{td},{cl},{cn},{cx},{cc},{co},{km},{cg},{cd},{ck},{cr},{ci},{hr},{cu},{cy},{cz},{dk},{dj},{dm},{do},{tp},{ec},{eg},{sv},{gq},{ee},{et},{fk},{fo},{fj},{fi},{fr},{fx},{gf},{pf},{tf},{ga},{gm},{ge},{de},{gh},{gi},{gr},{gl},{gd},{gp},{gu},{gt},{gn},{gw},{gy},{ht},{hm},{hn},{hk},{hu},{is},{in},{id},{ir},{iq},{ie},{im},{il},{it},{jm},{jp},{jo},{kz},{ke},{ki},{kp},{kr},{kw},{kg},{la},{lv},{lb},{ls},{lr},{ly},{li},{lt},{lu},{mo},{mk},{mg},{mw},{my},{mv},{ml},{mt},{mh},{mq},{mr},{mu},{yt},{mx},{fm},{md},{mc},{mn},{me},{ms},{ma},{mz},{mm},{na},{nr},{np},{an},{nl},{nc},{nz},{ni},{ne},{ng},{nu},{nf},{mp},{no},{om},{pk},{pw},{ps},{pa},{pg},{py},{pe},{ph},{pn},{pl},{pt},{pr},{qa},{re},{ro},{ru},{rw},{ws},{sm},{st},{sa},{uk},{sn},{rs},{sc},{sl},{sg},{sk},{si},{sb},{so},{as},{za},{gs},{su},{es},{lk},{sh},{kn},{lc},{pm},{vc},{sd},{sr},{sj},{sz},{se},{ch},{sy},{tw},{tj},{tz},{th},{tg},{tk},{to},{tt},{tn},{tr},{tm},{tc},{tv},{ug},{ua},{ae},{gb},{uk},{us},{um},{uy},{uz},{vu},{va},{ve},{vn},{vi},{wf},{eh},{ye},{zm},{zw};echo SETCONF StrictNodes=1 ;echo signal newnym; echo quit) | nc localhost 9060
		
		fi	 
		
		
		# If tor is dead revive it
		if [ -n $TIP_ADDR ]  
		then
			echo "Tor ip found  - $TIP_ADDR - will not revive it";	
			echo "fetchTorIP: The Tor ip:" $TIP_ADDR;
			echo $TIP_ADDR:$theCountryx > $Mykodachi_path/.eeds-tipinfo;			
		else
		    autotorvpn=$(cat $Mykodachi_path/torenabled|tr -d ' '); 
			autotornovpn=$(cat $Mykodachi_path/torenablednovpn|tr -d ' '); 
			if [[ $autotorvpn==1 ]] || [[ $autotornovpn==1 ]] 
			then 
				echo "Reviving tor no ip found";
				sudo /etc/init.d/tor restart;
				TIP_ADDR="";
			fi
		fi
	fi

}


function checkRemoteUpdates()
{
		
	R_status_file="$Mykodachi_path/status_R_updates";
	# get the content first
	cd  $Mykodachi_path/
	sudo rm -f $R_status_file
	curl -s -m 30 https://www.digi77.com/software/kodachi/kodachiremoteupdates7921731054/status_R_updates|cut -d , -f 2 > $R_status_file
	sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/status_R_updates;
	end_of_file=0;
	
	while [[ $end_of_file == 0 ]]
	do
		  read -r line
		  # the last exit status is the 
		  # flag of the end of file
		  end_of_file=$?;
		  x=$line;
		  if [[ $x == *$kodachi_version* ]]; then
				#echo $x;	   
			    toUpdate=$(echo $x | awk '{ gsub(/:+/, " " ); print $3; }');
			    #echo $toUpdate
			    echo "checkRemoteUpdates: $toUpdate";
			   
				if [[ "$toUpdate" == 1 ]];then
					echo $kodachi_version "has an update vale is: " $toUpdate "from the string: " $x;
					rm -f "$kodachi_version.zip"
					rm -f -r $kodachi_version
					wget "https://digi77.com/software/kodachi/kodachiremoteupdates7921731054/$kodachi_version" -q 
					mv $kodachi_version $kodachi_version.zip
					unzip -P 9q40@06e61-7iZ-59-8mt-A4-E6@ $kodachi_version.zip
					rm -f $kodachi_version.zip
					#sudo chown $LOGED_USER.$LOGED_USER $kodachi_version -R
					cd $kodachi_version
					sudo chmod +x rc
					#windows cause space error this is how to solve it
					sed -i 's/\r$//' rc
					sudo bash rc
					cd ..
					rm -f -r $kodachi_version
				else
					echo $kodachi_version "has no update value is: " $toUpdate "from the string: " $x;
				fi		  
		  fi
	  
	done < "$R_status_file"
	 
	
}

function copyAptsubs()
{
	
	# Additinal sources
	pFile="/etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list";
	pFilex2="/etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list.save";
	if !(grep -q libreoffice "$pFile") || !(grep -q libreoffice "$pFilex2") ; then
		  echo "Someone touched my additional apt files I will restore them";
		  echo " Removing all files";
		  sudo rm -f /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list
		  sudo rm -f /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list.save
		  sudo rm -f /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list
		  sudo rm -f /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list.save
		  sudo rm -f /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list
		  sudo rm -f /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list.save
		  sudo rm -f /etc/apt/sources.list.d/signal-xenial.list
		  sudo rm -f /etc/apt/sources.list.d/signal-xenial.list.save				  
		  sudo rm -f /etc/apt/sources.list.d/syncthing.list
		  sudo rm -f /etc/apt/sources.list.d/syncthing.list.save
		  sudo rm -f /etc/apt/sources.list.d/home:hawkeye116477:waterfox.list
		  sudo rm -f /etc/apt/sources.list.d/home:hawkeye116477:waterfox.list.save
		  
		  echo "Coping all files";
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/libreoffice-ubuntu-ppa-bionic.list /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/libreoffice-ubuntu-ppa-bionic.list.save /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list.save 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/micahflee-ubuntu-ppa-bionic.list /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/micahflee-ubuntu-ppa-bionic.list.save /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list.save 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list.save /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list.save 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/signal-xenial.list /etc/apt/sources.list.d/signal-xenial.list 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/signal-xenial.list.save /etc/apt/sources.list.d/signal-xenial.list.save			  
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/syncthing.list /etc/apt/sources.list.d/syncthing.list
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/syncthing.list.save /etc/apt/sources.list.d/syncthing.list.save 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/home_hawkeye116477_waterfox.list /etc/apt/sources.list.d/home_hawkeye116477_waterfox.list
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/home_hawkeye116477_waterfox.list.save /etc/apt/sources.list.d/home_hawkeye116477_waterfox.list.save
		  
		  
		  echo "Chown root all copied files";
		  sudo chown root.root /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list
		  sudo chown root.root /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list.save
		  sudo chown root.root /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list
		  sudo chown root.root /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list.save
		  sudo chown root.root /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list
		  sudo chown root.root /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list.save
		  sudo chown root.root /etc/apt/sources.list.d/signal-xenial.list
		  sudo chown root.root /etc/apt/sources.list.d/signal-xenial.list.save				  
		  sudo chown root.root /etc/apt/sources.list.d/syncthing.list
		  sudo chown root.root /etc/apt/sources.list.d/syncthing.list.save
		  sudo chown root.root /etc/apt/sources.list.d/home:hawkeye116477:waterfox.list
		  sudo chown root.root /etc/apt/sources.list.d/home:hawkeye116477:waterfox.list.save
		  
		  
	fi
	
}


function copyAptmains()
{
	#Main sources
	pFile="/etc/apt/sources.list";
	if (grep -q 'deb cdrom:\[Linux' "$pFile"); then
		echo "Someone touched my main apt files I will restore them";
		echo " Removing all files";
		sudo rm -f /etc/apt/sources.list
		sudo rm -f /etc/apt/sources.list.save 	
		echo "Coping all files";	
		sudo cp $Mykodachi_path/apt-live/sources.list /etc/apt/sources.list
		sudo cp $Mykodachi_path/apt-live/sources.list.save /etc/apt/sources.list.save 	
		echo "Chown root all copied files";
		sudo chown root.root /etc/apt/sources.list
		sudo chown root.root /etc/apt/sources.list.save 	
		echo "deb [trusted=yes] file:/cdrom/dists/ ./  # ISO repo - BB" |sudo tee -a /etc/apt/sources.list
	fi
	
}


function getBtCprice()
{
			#Get btc price
			#spare parts
			#curl -s https://www.btcturk.com/api/ticker|jq -r '.[5].last'
			
			torifySystem=$(cat $Mykodachi_path/torifysystemstatus);
			if [[ "$torifySystem" == *No* ]]
			then
				echo "Getting btc price":
				btcValue=$(curl -s -m 20 -X GET "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd" -H  "accept: application/json" |jq -r '.bitcoin.usd'|xargs|tr -d " \t\n\r");
				if [[ -n btcValue ]]
				then
					btcValue="\$$btcValue";
				else
					btcValue="Offline";
				fi
				echo -e $btcValue > $Mykodachi_path/btcprice;
				
				echo "Getting xmr price":
				xmrValue=$(curl -s -m 20 -X GET "https://api.coingecko.com/api/v3/simple/price?ids=monero&vs_currencies=usd" -H  "accept: application/json" |jq -r '.monero.usd'|xargs|tr -d " \t\n\r");
				if [[ -n btcValue ]]
				then
					xmrValue="\$$xmrValue";
				else
					xmrValue="Offline";
				fi
				echo -e $xmrValue > $Mykodachi_path/xmrprice;
				
			else
				echo "Skipping getting btc price torrified is on":
			fi	
			sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/btcprice;
			sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/xmrprice;
			

}			

# parameters acception

if [[ "$myAction" == *hardworknonet* ]]
then
	
	if [ ! -d $Mykodachi_path/tmp ]; then
		mkdir $Mykodachi_path/tmp;
		chown $LOGED_USER.$LOGED_USER $Mykodachi_path/tmp;
	fi;
	
	
	
	#NEW_UUID=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1)
	NEW_UUID="NMxllr4g5KWVmq9yYGMGX1uZ0vn6nfM3@Nonet@";
	me=$(basename "$(test -L "$0" && readlink "$0" || echo "$0")")

	lockdir=$Mykodachi_path/tmp/$NEW_UUID$me
	mkdir $lockdir || {
		echo "lock directory exists. exiting"
		exit 1
	}
	# take pains to remove lock directory when script terminates
	trap "rmdir $lockdir" EXIT INT KILL TERM 

	# rest of script here
	sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/tmp/$NEW_UUID$me
	
	
	# Check boot type
	theFile="$Mykodachi_path/boottype";
	m=$(sudo efibootmgr)
	if echo "$m" | grep -q "BootCurrent"; then
		echo   "UEFI"  > $theFile;
	else
		echo   "Legacy"  > $theFile;
	fi
	
	#Check if system installed
	
	# Old method of checkeing seed file now i replaced it with user id check dist back! 
	#theFile="$Mykodachi_path/persistent";
	#pFile="/cdrom/preseed/custom.seed";
	#if [ -e "$pFile" ]
	#then
		#if !(grep -q kodachi "$pFile"); then
			#echo   "Yes"  > $theFile;
		  
		#else
			#echo   "No"  > $theFile;
		#fi
	#else
	#	echo   "Yes"  > $theFile;
	#fi
		
	#Check if system installed
	theFile="$Mykodachi_path/persistent";
	xP=$(id -u $LOGED_USER)
	if [[ $xP == 990 ]] 
	then
		echo   "Yes"  > $theFile;
		 
	else
		echo   "No"  > $theFile;
		 
	fi
	
	#Reset version file
	echo $kodachi_version > $Mykodachi_path/version;
	
	#let it breath on start up
	sleep 15;
   
   while true; do
        SERVICE="";
		# 2 sec calls no net
		#Get memroy used
		getMem

 
		# Set interface type
		
		netStatustxt=$(cat $Mykodachi_path/netCurrentStatus);
		if [[ $netStatustxt == *Active* ]]
		then
			x54=$(ip route get 8.8.8.8 | sed -nr 's/.*dev ([^\ ]+).*/\1/p');
		else
			x54=$(find /sys/class/net ! -type d | xargs --max-args=1 realpath  | awk -F\/ '/pci/{print $NF}'|head -n1 | sed -e 's/\s.*$//');
		fi
		echo $x54 > $Mykodachi_path/intfused;
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/intfused;
		
		
		securityScore=0;
		
		# Set ipv6
		theIP6s=$(cat /proc/sys/net/ipv6/conf/all/disable_ipv6);
		
		if [[ $theIP6s == 1 ]]
		then
			echo "No" > $Mykodachi_path/ipv6status;
			securityScore=$((securityScore+10))
		else
			echo "Yes" > $Mykodachi_path/ipv6status;
		
		fi
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/ipv6status;
		
		# Set login status cony
		if(grep -R $LOGED_USER /usr/share/lightdm/lightdm.conf.d/60-xubuntu.conf)
		then
		    echo "Yes" > $Mykodachi_path/autologinstatus;
		else
			echo "No" > $Mykodachi_path/autologinstatus;
			securityScore=$((securityScore+10))
		fi
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/autologinstatus;
		
		
		# Set printer cups for conky
		if(sudo service cups status|grep inactive> /dev/null)
		then
			echo "No" > $Mykodachi_path/cupsstatus;
		else
			echo "Yes" > $Mykodachi_path/cupsstatus;
		fi
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/cupsstatus;

		
		
		# Set nuked on conky
		if (apt-mark showhold|grep cryptsetup-bin) 
		then
			echo "Yes" > $Mykodachi_path/nuked;
		else
			echo "No" >	$Mykodachi_path/nuked;
		fi
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/nuked;
		
		
		# Set TorDNS status conky
		if (grep -R Tor $Mykodachi_dns_path/dns1)
		then			 
			echo "Yes" > $Mykodachi_path/tordnsstatus;
		else
			echo "No" > $Mykodachi_path/tordnsstatus;
		
		fi
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/tordnsstatus;
		
		# Set hdd encryption status
		getSDA=$(lsblk|egrep crypt|cut -d _ -f 1| sed 's/[^a-zA-Z0-9]//g');	
		if [[ -n $getSDA ]] 
		then
			echo "Yes" > $Mykodachi_path/hddencrypted;
		else
			echo "No" > $Mykodachi_path/hddencrypted;
		
		fi
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/hddencrypted;
		
		#Calculate scores
		xP=$(id -u $LOGED_USER)
		if [[ $xP == *990* ]] 
		then
			securityScore=$((securityScore+10));
		else
		
			getSDA=$(lsblk|egrep crypt|cut -d _ -f 1| sed 's/[^a-zA-Z0-9]//g');	
			if [[ -n $getSDA ]] 
			then
				securityScore=$((securityScore+2));
				
				if (apt-mark showhold|grep cryptsetup-bin) 
				then					
					securityScore=$((securityScore+2));					
				fi
				
			fi
		fi
		
		SERVICE="KodachiBrowser";
		SERVICE2="firefox";
		if (ps ax | grep -v grep | grep $SERVICE| grep $SERVICE2> /dev/null)
		then
			securityScore=$((securityScore+10));
		fi
		
		
		theModel="";
		
		# Set security model
		torifySystem=$(cat $Mykodachi_path/torifysystemstatus);
		if [[ "$torifySystem" == *No* ]]
		then
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
			    SERVICE='tor-service';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					theModel="ISP->VPN->Tor";
					securityScore=$((securityScore+30))
					SERVICE='dnscrypt-proxy';
					if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
					then
						theModel="ISP->VPN->Tor->DNScrypt";
						securityScore=$((securityScore+15))
					else
					if (grep -R Tor $Mykodachi_dns_path/dns1)
					then
						securityScore=$((securityScore+20))
						theModel="ISP->VPN->Tor->TorDNS";
					fi
					fi
					
				else
					SERVICE='dnscrypt-proxy';
					if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
					then
						theModel="ISP->VPN->DNScrypt";
						securityScore=$((securityScore+35))
					else
						theModel="ISP->VPN";
						securityScore=$((securityScore+20))
					fi
				fi
			else
				theModel="ISP";
				SERVICE='dnscrypt-proxy';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					theModel="ISP->DNScrypt";
					securityScore=$((securityScore+15))
				else
				if (grep -R Tor $Mykodachi_dns_path/dns1)
				then
				    securityScore=$((securityScore+20))
					theModel="ISP->TorDNS";
				fi
				fi
				SERVICE='tor-service';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					theModel="ISP->Tor";
					securityScore=$((securityScore+10))
					SERVICE='dnscrypt-proxy';
					if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
					then
						theModel="ISP->Tor->DNScrypt";
						securityScore=$((securityScore+15))
					else
					if (grep -R Tor $Mykodachi_dns_path/dns1)
					then
						securityScore=$((securityScore+20))
						theModel="ISP->Tor->TorDNS";
					fi
					fi
				fi
			fi
		else
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				securityScore=$((securityScore+40))
				theModel="ISP->VPN->Torify";				 
				if (grep -R Tor $Mykodachi_dns_path/dns1)
				then
					theModel="ISP->VPN<->Torify->TorDNS";
					securityScore=$((securityScore+20))
				fi
			else
				theModel="ISP->Torify";
				securityScore=$((securityScore+20))
				if (grep -R Tor $Mykodachi_dns_path/dns1)
				then
				    securityScore=$((securityScore+20))
					theModel="ISP->Torify->TorDNS";
				fi
			fi
		fi
		echo $theModel > $Mykodachi_path/securitymodel;
		echo $theModel;
		#end scurity model check
		
		
		# Check force via vpn stuff
		if [[ "$torifySystem" == *No* ]]
		then
		
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				 								
				if(sudo ufw status |grep tun0 > /dev/null)
				then
					
					securityScore=$((securityScore+2));
				
				fi			
								
				
				myCard=$(cat /home/$LOGED_USER/.kbase/intfused |xargs)
				if(sudo ufw status |grep $myCard > /dev/null)
				then
					
					securityScore=$((securityScore+2));
				
				fi
			fi				
				
		fi
		
		
	
        # Print the score
        echo $securityScore > $Mykodachi_path/securityscore;
        sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/securityscore;
        
        
        
        # for conky ufw status		 
		
		if (sudo ufw status|grep inactive)
		then
			echo "No" > $Mykodachi_path/vpnufwstatus;
		else
			echo "Yes" > $Mykodachi_path/vpnufwstatus;
		fi
        sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/vpnufwstatus;
        
        # for conky tor on vpn
        autotorvpn=$(cat $Mykodachi_path/torenabled|tr -d ' '); 
        if [[ "$autotorvpn" == *1* ]]
        then
			echo "Yes" > $Mykodachi_path/toronvpn;
        else
        
			echo "No" > $Mykodachi_path/toronvpn;
        fi
        sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/toronvpn;
        
		# Installer icon offline
		fileIcon="$Myhome_path/Desktop/Install_Kodachi_Offline.desktop";
		fileIconkbase="$Mykodachi_path/Install_Kodachi_Offline.desktop";
		pFile="/cdrom/preseed/custom.seed";
		# romove install icon
		xP=$(id -u $LOGED_USER)
		if [[ $xP == *990* ]] 
		then
			echo "System not installed keep the icon:$xP";
			# Check icon file if does not exists
			
			if [[ ! -f $fileIcon ]];  
			then
				cp $fileIconkbase $fileIcon;
				
			fi
			sudo chmod +x $fileIcon;
			sudo chown $LOGED_USER.$LOGED_USER $fileIcon;
			rm -f $Myhome_path/Desktop/ubiquity.desktop
		else
			echo "System installed will delete icon:$xP";
			rm -f $fileIcon;
			rm -f $Myhome_path/Desktop/ubiquity.desktop
		fi
		
		
			
		# For online cancelled due errors
		# Installer icon Online
		#fileIcon="$Myhome_path/Desktop/Install_Kodachi_Online.desktop";
		#fileIconkbase="$Mykodachi_path/Install_Kodachi_Online.desktop";
		#pFile="/cdrom/preseed/custom.seed";
		# romove install icon
		 
	 
		
		
		
		# Version file  check if file is empty
		fileV="$Mykodachi_path/version";
		if [ -e "$fileV" ];
		then
		    theFileVersion=$(cat $Mykodachi_path/version);
			if [[ $theFileVersion > 0 ]]  
			then
				echo "skip file version append file not empy"
			else
				echo "Empty version found printed default: $kodachi_version"
				sudo echo $kodachi_version > $Mykodachi_path/version;
				
			
			fi
		else
			 echo "No version found printed default: $kodachi_version"
			 sudo echo $kodachi_version > $Mykodachi_path/version;
		fi
		sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/version;
		
		
		# Check DNS and auto start if not ruuning
		checkDNSisRunning
		
		# Set owner of files
		#sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path -R
		
		# Remove crap files from home
		rm -f $Mykodachi_path/wget-log*
		rm -f $Mykodachi_path/kodachi-vpn.zip.*
		
		
		
		#monitor my apts so ubiquity and pinguy don't play with it
		xP=$(id -u $LOGED_USER)
		if [[ $xP == 990 ]] 
		then
			
			copyAptsubs;
			copyAptmains;
	
			
		else # System installed 
			
			firstboot=$(cat $Mykodachi_path/firstboot);	 
			if [[ "$firstboot" == 1 ]]
			then
				copyAptsubs;
				copyAptmains;
			fi
		
		fi
	  
		
		
		
		
		# if we have stop vpn command
		vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' ');
		# Stop vpn service
		if [[ "$vpntype" == *novpn* ]]
		then
			
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
			    echo "novpn command received I will stop vpn type:$vpntype";	 
				sudo killall -SIGINT openvpn;
				notify-send -i $notifyIcon "VPN is shutdown";  
		        autotorvpn=$(cat $Mykodachi_path/torenabled|tr -d ' '); 
				autotornovpn=$(cat $Mykodachi_path/torenablednovpn|tr -d ' '); 
				if  [[ "$autotornovpn" == *1* ]] 
				then
					#SERVICE='tor-service';
					#if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)
					#then
						echo "Restarting tor after stopping vpn";
						notify-send -i $notifyIcon "Restarting Tor after VPN shutdown";
						sudo /etc/init.d/tor restart;
						#sleep 5;
					#fi
				else
					if !(grep -R Tor $Mykodachi_dns_path/dns1)
					then
						sudo /etc/init.d/tor stop;				
						TIP_ADDR="";
					fi
			
				
				fi
				
			    resetips;
			    echo "1" > $Mykodachi_path/actionpicker;
				echo "Disabled"  > "$Mykodachi_path/vpntype";
			fi
	
			
		fi
		
		         
		
		
		
		# Auto start and stop tor
		autotorvpn=$(cat $Mykodachi_path/torenabled|tr -d ' '); 
		autotornovpn=$(cat $Mykodachi_path/torenablednovpn|tr -d ' '); 
		if [[ "$autotorvpn" == *1* ]]
		then
			
			
			echo "tor is set to autotorvpn:$autotorvpn";
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				SERVICE='tor-service';
				if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "tor was not running run it"
					sudo /etc/init.d/tor restart;
					TIP_ADDR="";
				fi					
			else
				if !(grep -R Tor $Mykodachi_dns_path/dns1)
				then
					sudo /etc/init.d/tor stop;				
					TIP_ADDR="";
				fi
			
			fi
				
		fi
		
		
		
		autotorvpn=$(cat $Mykodachi_path/torenabled|tr -d ' '); 
		autotornovpn=$(cat $Mykodachi_path/torenablednovpn|tr -d ' '); 
		if [[ "$autotornovpn" == *1* ]]
		then
			echo " tor is set to autotorNovpn:$autotornovpn";
			SERVICE='tor-service';
			if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				echo "Tor is in auto without vpn value: "$autotornovpn
				echo "Enabling tor without vpn"
				sudo /etc/init.d/tor restart;
				TIP_ADDR="";
			fi  
		fi

		 
		  
		  
	
		autotorvpn=$(cat $Mykodachi_path/torenabled|tr -d ' '); 
		autotornovpn=$(cat $Mykodachi_path/torenablednovpn|tr -d ' '); 	
		torifySystem=$(cat $Mykodachi_path/torifysystemstatus);	  
		# Stop Tor command received
		if [[ "$autotorvpn" == *0* ]] && [[ "$autotornovpn" == *0* ]] && [[ "$torifySystem" == *No* ]]
		then
			
			
			if(grep -R Tor $Mykodachi_dns_path/dns1)
			then
				notify-send -i $notifyIcon "Tor DNS is on if you shutdown Tor you will loose Internet connection" \ "Please change to other DNS provider first" ;	
			    echo "0" > /home/$LOGED_USER/.kbase/torenabled
				echo "1" > /home/$LOGED_USER/.kbase/torenablednovpn 
			else
				SERVICE='tor-service';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					sudo /etc/init.d/tor stop; 
					notify-send -i $notifyIcon "TOR has shutdown";  
					
					echo "stopping tor by stop tor command";
					echo "" > $Mykodachi_path/.eeds-tipinfo;
				fi
			fi
		fi
		  
		  

	
		
		sleep 5;

	done	
fi
  
  
  
  
  
  
  
  
  
  
######### HardworkNet##################################  

if [[ "$myAction" == *hardworknet* ]]
then    


	if [ ! -d $Mykodachi_path/tmp ]; then
		mkdir $Mykodachi_path/tmp;
		chown $LOGED_USER.$LOGED_USER $Mykodachi_path/tmp;
	fi;
	
    #NEW_UUID=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1)
	NEW_UUID="W2ygSm9EdXbKkbqip7EtWwHdDYWkytai@net@";
	me=$(basename "$(test -L "$0" && readlink "$0" || echo "$0")")

	lockdir=$Mykodachi_path/tmp/$NEW_UUID$me
	mkdir $lockdir || {
		echo "lock directory exists. exiting"
		exit 1
	}
	# take pains to remove lock directory when script terminates
	trap "rmdir $lockdir" EXIT INT KILL TERM 

	# rest of script here
	sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/tmp/$NEW_UUID$me
	
	# Clean logged files for ip info 
	echo "" > $Mykodachi_path/.eeds-ipinfo;
	echo "" > $Mykodachi_path/.eeds-tipinfo;
	echo "0" > $Mykodachi_path/actionpicker;

	theIPcounter=0;  
	killVPNTorcounter=0
	
	#let it breath on start up
	sleep 30;
	
		 
	while true; do
		#resetips;
		randomdomain=$(cat $Mykodachi_path/workingdomain.txt | xargs shuf -n1 -e);
		echo "Ip domain:" $randomdomain;
		
		if [ ! -n $randomdomain ]
		then
			echo " Random domain was empty so we set digi77 domain";
			randomdomain="https://www.digi77.com/software/vpn/ipcheckplain.php";
		fi
		
		actionpickervalue=$(cat $Mykodachi_path/actionpicker);
		ipsourcefile=$(cat $Mykodachi_path/ipretrievetype.txt);
			
		fileIPaddress=$(cat $Mykodachi_path/.eeds-ipinfo);
		fileTORIPaddress=$(cat $Mykodachi_path/.eeds-tipinfo);
		vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' ');
		SERVICE="";
		SERVICE2="";
		
		# Get local id
		getID;
		
		if [[ $actionpickervalue == 1 ]]
		then
			clear;
			echo "############# SOS action ##########";
		fi
		
		if [[ $theIPcounter == 0 ]]
		then
			clear;
			echo "############# Baby born ##########";
			
		fi
		clear;
		echo "The counter is: $theIPcounter";
		
		# Print currnet ip used domain
		echo "domain extracting original was $randomdomain";
		s=$randomdomain;

		# Trim url for conky
		if [[ ! $randomdomain = *"http"* ]]; 
		then
			x475=$(echo $s | awk '{gsub("http://|/.*","")}1');
			echo "1: " $x475
		else
			x475=$(echo $s |sed -E -e 's_.*://([^/@]*@)?([^/:]+).*_\2_');
			echo "2: " $x475
		fi
		echo $x475 > $Mykodachi_path/randomDomain;


		# Set ipsource in letter for conky use
					 
		if [[ "$ipsourcefile" == 1 ]]
		then
			echo "Ip sourcse is digi77";
			echo "Digi77" > $Mykodachi_path/iptypeletter;
		else
			echo "Ip sourcse is other sites";
			echo "other sites" > $Mykodachi_path/iptypeletter;
		fi
		
		
	       

       
		
		# Fetch ip address
		# make sure we have internet before starting   
		echo "Current net check domain is $netIP";
		ping -c1 -W 2 "$netIP" &> /dev/null
		if [ $? -eq 0 ]; 
		then
			
			#Report net status
			echo "Google is fine";
			echo "Active" > $Mykodachi_path/netCurrentStatus;
			netIP='google.com';
			
			
			fileDomain2="$Mykodachi_path/workingdomaintmp.txt";
			fileDomain1="$Mykodachi_path/workingdomain.txt";
			#Return our domain settings
			if [[ "$ipsourcefile" == 0 ]]
			then
				if [[ "$randomdomain" == *digi77* ]]
				then
					if [[ -f $fileDomain2 ]];  
					then
						mv $fileDomain2 $fileDomain1;
						sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/workingdomain.txt;
						sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/workingdomaintmp.txt;
					fi
				fi
			fi
			
			
			
			
			
			
		 
		
			#check if we have vpn ip or not
	      	if !(grep -R : $Mykodachi_path/.eeds-ipinfo)
	      	then
				echo "Net is here but we have Missing VPN IPS so we fetch them";
				echo "Running" > $Mykodachi_path/healthsactionstatus;										
				fetchNormalIP;					
	      	fi
	        
			
			
			
			# If we have vpn on but ip is not secure
			SERVICE='openvpn';				 
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				if [[ "$fileIPaddress" == *notsecure* ]]
				then
															
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					echo "Vpn is on but ip not secure rfetch:$fileIPaddress";
					fetchNormalIP;							
									
					
				fi
			fi	
			
			
			
			
		
			
			
			# Check if we have tor ip
			torFilecounter=$(cat $Mykodachi_path/.eeds-tipinfo|wc -c)
			#if !(grep -R : $Mykodachi_path/.eeds-tipinfo> /dev/null )
	      	if [[ $torFilecounter -lt 5 ]] || [[ ! -n $TIP_ADDR ]] || [[ $fileTORIPaddress == ":" ]] 
	      	then
				SERVICE='tor-service';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "Net is here but we have Missing TOR file IPS so we fetch them";
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					fetchTorIP;
					echo "Fetch Tor call 2";
					tornullipcounter=$((tornullipcounter+1)) 
					echo "tornullipcounter:$tornullipcounter";				 
					
				fi			
	      	else
	      	
				tornullipcounter=0;
	      	fi
	      	
	      	
	      
			
			
		    # Catch tor if its lieng to us with the ip!	
			SERVICE='tor-service';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				# if tor is running but node is dead we renew it 
				# Give it a chnce to get the ip
				if [[ $tornullipcounter -eq 3 ]] 
				then
					#sudo /etc/init.d/tor restart;
					echo "Tor working but no ip restarting tor circuites";
					(echo authenticate '"Auo2@s3ks@Wdq"';echo SETCONF ExitNodes={ac},{af},{ax},{al},{dz},{ad},{ao},{ai},{aq},{ag},{ar},{am},{aw},{au},{at},{az},{bs},{bh},{bd},{bb},{by},{be},{bz},{bj},{bm},{bt},{bo},{ba},{bw},{bv},{br},{io},{vg},{bn},{bg},{bf},{bi},{kh},{cm},{ca},{cv},{ky},{cf},{td},{cl},{cn},{cx},{cc},{co},{km},{cg},{cd},{ck},{cr},{ci},{hr},{cu},{cy},{cz},{dk},{dj},{dm},{do},{tp},{ec},{eg},{sv},{gq},{ee},{et},{fk},{fo},{fj},{fi},{fr},{fx},{gf},{pf},{tf},{ga},{gm},{ge},{de},{gh},{gi},{gr},{gl},{gd},{gp},{gu},{gt},{gn},{gw},{gy},{ht},{hm},{hn},{hk},{hu},{is},{in},{id},{ir},{iq},{ie},{im},{il},{it},{jm},{jp},{jo},{kz},{ke},{ki},{kp},{kr},{kw},{kg},{la},{lv},{lb},{ls},{lr},{ly},{li},{lt},{lu},{mo},{mk},{mg},{mw},{my},{mv},{ml},{mt},{mh},{mq},{mr},{mu},{yt},{mx},{fm},{md},{mc},{mn},{me},{ms},{ma},{mz},{mm},{na},{nr},{np},{an},{nl},{nc},{nz},{ni},{ne},{ng},{nu},{nf},{mp},{no},{om},{pk},{pw},{ps},{pa},{pg},{py},{pe},{ph},{pn},{pl},{pt},{pr},{qa},{re},{ro},{ru},{rw},{ws},{sm},{st},{sa},{uk},{sn},{rs},{sc},{sl},{sg},{sk},{si},{sb},{so},{as},{za},{gs},{su},{es},{lk},{sh},{kn},{lc},{pm},{vc},{sd},{sr},{sj},{sz},{se},{ch},{sy},{tw},{tj},{tz},{th},{tg},{tk},{to},{tt},{tn},{tr},{tm},{tc},{tv},{ug},{ua},{ae},{gb},{uk},{us},{um},{uy},{uz},{vu},{va},{ve},{vn},{vi},{wf},{eh},{ye},{zm},{zw};echo SETCONF StrictNodes=1 ;echo signal newnym; echo quit) | nc localhost 9060
					tornullipcounter=0;
				fi
			fi
		
		
		
		
			# Make sure vpn is established and we have secure ip
			torifySystem=$(cat $Mykodachi_path/torifysystemstatus);
			if [[ "$torifySystem" == *No* ]]
			then 
				# If we have same ip multi times disconnect vpn
				SERVICE='openvpn';				 
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					if [[ "$IP_ADDRPublic" == "$originalIP" ]]  
					then
						sameipCounter=$((sameipCounter+1));
						fetchNormalIP;	 
						echo "Found same ip for ISP and VPN counter:$sameipCounter";
					else
						sameipCounter=0;
					
					fi
					
					if [[ $sameipCounter == 3 ]]
					then
						notify-send -i $notifyIcon "ISP IP is same as VPN IP so VPN will be restarted" \ "ISP IP: $originalIP = VPN IP: $IP_ADDRPublic";
						sameipCounter=0;
						sudo killall -SIGINT openvpn;
						echo "Counter = 3 killed VPN";
						
					fi
					
				fi
			fi
			
			
			
			# Start Own VPN
			vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' ');  			
			if [[ "$vpntype" == *ownvpn* ]]
			then
				
				echo "my ip inside own vpn function is:" $IP_ADDRPublic
				
				SERVICE1='myownvpn.ovpn';
				SERVICE2='openvpn';				 
				if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
				then
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					echo "Starting own vpn now";
					startvpnfunction;
					actionpickervalue=1;
					IP_ADDRPublic="";				
					
				fi  
				    
			fi
			
			
			
			# Start Nord VPN
			vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' '); 	
			if [[ "$vpntype" == *nordvpn* ]]
			then
				
				echo "my ip inside Nord vpn function is:" $IP_ADDRPublic
				
				SERVICE1='vpnnordovpnfiles';
				SERVICE2='openvpn';				 
				if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
				then
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					echo "Starting Nord vpn now";
					startvpnfunction;
					actionpickervalue=1;
					IP_ADDRPublic="";					
				fi  
				    
			fi
			
			
			# Start hideme VPN
			vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' '); 	
			if [[ "$vpntype" == *hideme* ]]
			then
				
				echo "my ip inside Hideme vpn function is:" $IP_ADDRPublic
				
				SERVICE1='vpnhidemeovpnfiles';
				SERVICE2='openvpn';				 
				if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
				then
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					echo "Starting Hideme vpn now";
					startvpnfunction;
					actionpickervalue=1;
					IP_ADDRPublic="";					
				fi  
				    
			fi
			
			# Start Proton VPN
			vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' '); 	
			if [[ "$vpntype" == *proton* ]]
			then
				
				echo "my ip inside Proton vpn function is:" $IP_ADDRPublic
				
				SERVICE1='vpnprotonovpnfiles';
				SERVICE2='openvpn';				 
				if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
				then
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					echo "Starting Proton vpn now";
					startvpnfunction;
					actionpickervalue=1;
					IP_ADDRPublic="";					
				fi  
				    
			fi
			
			
			# Start Vpngate
			vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' '); 	
			if [[ "$vpntype" == *vpngate* ]]
			then
				
				echo "my ip inside VPNGate  function is:" $IP_ADDRPublic
				
				SERVICE1='vpngateovpnfiles';
				SERVICE2='openvpn';				 
				if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
				then
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					echo "Starting VPNGate now";
					startvpnfunction;
					actionpickervalue=1;
					IP_ADDRPublic="";
					
				fi  
				    
			fi
			
			
			
			# Start KernVPN
			vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' '); 	
			if [[ "$vpntype" == *kernvpn* ]]
			then
				
				echo "my ip inside KernVPN  function is:" $IP_ADDRPublic
				
				SERVICE1='vpnkernovpnfiles';
				SERVICE2='openvpn';				 
				if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
				then
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					echo "Starting KernVPN now";
					startvpnfunction;
					actionpickervalue=1;
					IP_ADDRPublic="";
				
				fi  
				    
			fi
			
			
		
				


			# Start kodachi vpn
			vpntype=$(cat $Mykodachi_path/vpntype|tr -d ' '); 
			if [[ "$vpntype" == *kodachivpn* ]]
			then
				 
				 if [[ "$Ban_Status" == *Banned* ]]
				then
					banAction 	
				else
					SERVICE1='/etc/openvpn/kodachi-vpn.ovpn';
					SERVICE2='openvpn';				 
					if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
					then
						echo "Running" > $Mykodachi_path/healthsactionstatus;
						 
						startvpnfunction;					
						actionpickervalue=1;						
					fi
					
					
				fi   
			fi
		
			
			
			
			
			# Call ips if we have sos
			actionpickervalue=$(cat $Mykodachi_path/actionpicker);
			if [[ "$actionpickervalue" == 1 ]]
			then
				echo "Calling ips picker is:$actionpickervalue"
				sleep 5;									
				fetchNormalIP;				
     			SERVICE='tor-service';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "Running" > $Mykodachi_path/healthsactionstatus;
					fetchTorIP;
				fi
				#theIPcounter=4;
			
			fi
			
			
			if [[ $ipsourcefile == 0 ]]
			then
				 # If something wrong with other domain don't wait for counters
				mq=$(wc -l < $Mykodachi_path/workingdomain.txt)
				# If only we have less than 3 domains than we have an issue
				echo "Inside Emergency domain checker ";
				if [[ $mq -lt 3 ]]
				then						    
					echo "Regular domain update ipsource=0 and we have less than 3 lines:$mq";
					sudo bash $Mykodachi_path/ipcheck -a other;	
				else
				   echo "Skipping other domain checker lines:$mq";
				fi
			fi
			
			#routine stuff
			actionpickervalue=$(cat $Mykodachi_path/actionpicker);
			if [[ "$actionpickervalue" == 0 ]]
			then
			
			    #get btc price
				getBtCprice;
				
				if [ $theIPcounter == 6 ] || [ $theIPcounter == 12 ] || [ $theIPcounter == 18 ] || [ $theIPcounter == 24 ]; then 
					echo "Calling ips and net found stuff counter: $theIPcounter":
					echo "Running" > $Mykodachi_path/healthsactionstatus;
										
									
					fetchNormalIP;			
					
										
					SERVICE='tor-service';
					if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
					then
						fetchTorIP;
					fi

					#if [[ "$vpntype" == *kodachivpn* ]]  
					#then					
						#fetchKodachiIP;
					#fi
			 
												
					# Check if user is banned
					getBan
					
					
					#Check for updates
					checkRemoteUpdates
					
					# Get version online
					getVersion
				    
				    
						
					
					if [ $theIPcounter == 12 ] || [ $theIPcounter == 24 ]
					then
						
						
						echo " Regular domain checkup counter is:12 || 24";
						if [[ $ipsourcefile == 1 ]]
						then
							
							echo "Regular domain update ipsource=1 and we have net on digi setting Digi77";
							url2="https://www.digi77.com/software/vpn/ipcheckplain.php";
							echo $url2 > $Mykodachi_path/workingdomain.txt;
						    sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/workingdomain.txt;
						else
						    echo "Regular domain update will run routine";
							sudo bash $Mykodachi_path/ipcheck -a other;								
						fi		
						# Get BTc price
						getBtCprice						
					fi # if counter=24
					
				else
					echo "###Skipping net functions for now  counter is !=6 !=12 !=18 or !=24 ###";
					#echo "Auto Pause" > $Mykodachi_path/healthsactionstatus;
				fi	# end counter 1 and 4 actions
					
					
				
				
				
				
				
				#If working random domain is empty which means file was empty we shoud fix it			
				if [ ! -n "$randomdomain" ]     
				then 	
					if [[ "$ipsourcefile" == 1 ]]
					then
							
						echo "Regular domain update ipsource=1 and we have net on digi setting Digi77";
						url2="https://www.digi77.com/software/vpn/ipcheckplain.php";
						echo $url2 > $Mykodachi_path/workingdomain.txt;
						sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/workingdomain.txt;
						
					else
						echo "Regular domain update ipsource=0 and we havenet setting to other";
						sudo bash $Mykodachi_path/ipcheck -a other;	
					fi							
				fi #If working random domain is empty which means file was empty we shoud fix it	
				
				
				
				# If domain file is deleted
				fileDomain="$Mykodachi_path/workingdomain.txt";
				if [[ ! -f $fileDomain ]];  
				then
					if [[ "$ipsourcefile" == 1 ]]
					then
							
						echo "Regular domain update ipsource=1 and we have net on digi setting Digi77";
						url2="https://www.digi77.com/software/vpn/ipcheckplain.php";
						echo $url2 > $Mykodachi_path/workingdomain.txt;
						sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/workingdomain.txt;
						
					else
						echo "Regular domain update ipsource=0 and we havenet setting to other";
						sudo bash $Mykodachi_path/ipcheck -a other;	
					fi					
				fi # If domain file is deleted
				
					
				
				
				
					
				 
			fi # end routine stuff
			

	
			
			 
			
			
			
			fileIPaddress=$(cat $Mykodachi_path/.eeds-ipinfo);
			fileTORIPaddress=$(cat $Mykodachi_path/.eeds-tipinfo);
			echo "Net Stored Kodachi IP Address: $IP_ADDR";
			echo "Net Stored Normal IP Address: $IP_ADDRPublic";
			echo "Net Stored TOR IP Address: $TIP_ADDR";
			echo "Net file Stored Kodachi IP Address: $fileIPaddress";
			echo "Net file Stored Normal IP Address: $fileIPaddress";
			echo "Net file Stored TOR IP Address: $fileTORIPaddress";
			
			
			# if we have a command from user don't sleep 
			actionpickervalue=$(cat $Mykodachi_path/actionpicker);
			if [[ "$actionpickervalue" == 0 ]]
			then
						
				echo "Going to sleep we have net";
				echo "Auto Pause" > $Mykodachi_path/healthsactionstatus;
				sleep 5;
				echo " finish sleeping ";
			else			
				echo "Skiped sleeping we have action";
				#theIPcounter=2;
				echo "0" > $Mykodachi_path/actionpicker;
			fi
			
			
			echo " End of net check counter is:" $theIPcounter
			if [ $theIPcounter = 24 ] ; then
				theIPcounter=0;
				echo "Reseting the counter to 0 from 24";
			fi
   
			killVPNTorcounter=0;
			 
			echo "Active" > $Mykodachi_path/netCurrentStatus;
			theIPcounter=$((theIPcounter+1))   
			
			killVPNTorcounterpopup=0;
		else ##### No NET actions####
		    echo "Not active" > $Mykodachi_path/netCurrentStatus;
			killVPNTorcounter=$((killVPNTorcounter+1))  
			echo "Net offline no ping no ip found in $fileIPaddress we found:$fileIPaddress the counter is  $killVPNTorcounter"
			netIP='digi77.com';
			echo "Replaced google with digi77.com";
			theIPcounter=0; 
			#notify-send -i $notifyIcon "Offline $killVPNTorcounter";
			
			if [[ "$ipsourcefile" == 0 ]]
			then
				fileDomain2="$Mykodachi_path/workingdomaintmp.txt";
				fileDomain1="$Mykodachi_path/workingdomain.txt";
				if [[ ! -f $fileDomain2 ]];  
				then
					cp $fileDomain $fileDomain2
				fi
				url2="https://www.digi77.com/software/vpn/ipcheckplain.php";
				echo $url2 > $Mykodachi_path/workingdomain.txt;
				sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/workingdomain.txt;
				sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/workingdomaintmp.txt;
			fi
			
			# no internet
			fileIPaddress=$(cat $Mykodachi_path/.eeds-ipinfo);
			fileTORIPaddress=$(cat $Mykodachi_path/.eeds-tipinfo);
			echo "No internet now ! killing VPN"
			echo "No Net! Stored Kodachi IP Address: $IP_ADDR";
			echo "No Net! Stored Normal IP Address: $IP_ADDRPublic";
			echo "No Net! Stored TOR IP Address: $TIP_ADDR"; 
			echo "No Net! file Stored Kodachi IP Address: $fileIPaddress";
			echo "No Net! file Stored Normal IP Address: $fileIPaddress";
			echo "No Net! file Stored TOR IP Address: $fileTORIPaddress";
			if [ $killVPNTorcounter = 3 ]; then
				echo "No net trigger kill vpn and tor"
				sudo killall -SIGINT openvpn;
				autotornovpn=$(cat $Mykodachi_path/torenablednovpn|tr -d ' '); 
				if [[ "$autotornovpn" == 0 ]]
				then
					sudo /etc/init.d/tor stop;
					TIP_ADDR="";
				fi
				killVPNTorcounter=0;
				#theIPcounter=2;
			fi
			
			
			killVPNTorcounterpopup=$(($killVPNTorcounterpopup+1))
			echo "Network fix popup counter: $killVPNTorcounterpopup";
			if [ $killVPNTorcounterpopup = 12 ]; then				
				
				#Maybe will use it again in future 
				#timeout 60 xfce4-terminal -e 'bash -c "sudo bash ~/.kbase/recovernetworkpopup; bash"' -T "Internet recovery"
				notify-send -i $notifyIcon "Internet connection lost you can try to recover it by going to:
Panic room menu then -> Repair Network"; 

				
			fi
		
			# if we have a command from user don't sleep 
			actionpickervalue=$(cat $Mykodachi_path/actionpicker);
			if [[ "$actionpickervalue" == 0 ]]
			then
				echo "Going to sleep no Net will sleep for 5 sec only";
				echo "Auto Pause" > $Mykodachi_path/healthsactionstatus;
				sleep 5;				
				echo " finish sleeping ";
			else			
				echo "Skiped sleeping we have action";
				#theIPcounter=2;
				echo "0" > $Mykodachi_path/actionpicker;
			fi		
			 
			
		fi # for net check
	

 
     
 
	# Reset conky 2 timer
	#rm -f > $Mykodachi_path/.countfile;
	actionpickervalue=0;
	echo "Auto Pause" > $Mykodachi_path/healthsactionstatus;
	done	
	


fi # for hardwoknet action




#cheat sheet
#sudo kill -9 `ps -ef | grep hardworknet | grep -v grep | awk '{print $2}'`
#sudo kill -9 `ps -ef | grep hardworknonet | grep -v grep | awk '{print $2}'`
#sudo bash systemhealth -a hardworknonet
#sudo bash systemhealth -a hardworknet


